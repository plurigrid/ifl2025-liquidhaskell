\documentclass[acmtog, anonymous]{acmart}
\usepackage[utf8]{inputenc}
\usepackage{fancyvrb}

\title{Interface design with SMT solvers: A study}

\author{undisclosed author/s}
\author{Facundo Dom√≠nguez}
\affiliation{
     \institution{Tweag}
     \country{Uruguay}
}
\email{facundo.dominguez@tweag.io}
\author{Arnaud Spiwack}
\affiliation{
     \institution{Tweag}
     \country{Japan}
}
\email{arnaud.spiwack@tweag.io}
\keywords{refinement types, SMT solvers, static analysis, formal verification}
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10003752.10010124.10010138.10010142</concept_id>
       <concept_desc>Theory of computation~Program verification</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10010124.10010138.10010140</concept_id>
       <concept_desc>Theory of computation~Program specifications</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Program verification}
\ccsdesc[500]{Theory of computation~Program specifications}

\newcommand{\tc}[1]{\texttt{#1}}
\newcommand{\codeblocksize}{\fontsize{6.5}{9}\selectfont}
\newcommand{\sourcefile}[1]{\anon[#1 (in accompanying zip file)]{{\scriptsize\url{https://github.com/facundominguez/liquidhaskell/blob/fd/rapier/tests/rapier/#1}}}}
\RecustomVerbatimEnvironment{verbatim}{Verbatim}{
    fontsize=\codeblocksize,
}

\begin{document}
\maketitle

\section{Introduction}

Application programming interfaces (APIs) in programming languages are described
with the types of their operations and additional documentation expressed by
other means than the programming language itself.

In strongly typed languages, the author of an interface can aim to enrich the
types to represent most of the constraints and relationships between the
operations, or she could decide to keep the types as simple as possible.

The advantage of rich types is that the type checker is involved in detecting
misuse of the interface, thus preventing execution failures or returning
incorrect results. But the enrichment always comes at the cost of more
complexity in the usage of the interface, which in the extreme can make the
interface too difficult to use as well. The author is then forced into a
balancing act.

The options are not just to lean or not to lean on the type checker, though. In
this paper we analyze a couple of use cases in the Haskell programming language
from the perspective of a third alternative. We implement the static checks of
the interfaces with automated theorem provers, more specifically, SMT solvers.
And we connect SMT solvers with Haskell by using refinement types as implemented
in the Liquid Haskell verification tool.

While SMT solvers have been intended to support programming since long, it has
been less discussed how their integration through refinement types influences
interface design. Therefore, our first contribution is a study of
capture-avoiding substitution with safety checks implemented with Liquid Haskell,
where we compare with an earlier attempt based on the Haskell type checker and known as
\textit{the foil}~\cite{maclaurin2022foil}
(Section~\ref{capture-avoiding-substitution}). Later on, we implement safety checks
in an implementation of unification (Section~\ref{unification}), a more demanding
example where extending earlier approaches would be some challenge. Our
attempt with unification is only partially successful, though it allows to
estimate what it would take to complete it, which motivates our third
contribution: a discussion of the limitations of both the Liquid Haskell
implementation and the general approach of integrating SMT solvers via refinement
types. In a nutshell, we anticipate many scenarios where the integration of SMT
solvers makes programming more pleasant and static checks more powerful.


\section{Capture-avoiding substitutions}
\label{capture-avoiding-substitution}

Name capture is recognized as one of the most common mistakes when writing compilers.
A way to make it happen is when substituting under binders like in
$(\lambda x. y)[y:=t]$. The result of the substitution is $\lambda x. t$.
Thus $(\lambda x. y)[y:=z]$ is $\lambda x. z$, and after the substitution
we still have a function that returns a constant value. But if we substitute
as in $(\lambda z. y)[y:=z]$, we obtain $\lambda z. z$, the identity function!
This change of meaning is often unwanted and is caused by the binder capturing
free variables in $t$.

Avoiding name captures efficiently is the subject of a few approaches. One of them,
called \textit{the rapier}, is used in the GHC compiler. The rapier requires the
implementation of substitutions to carry an additional \textit{scope} set containing all the
variables that appear free in the result of the substitution. This set is
used both to decide what to rename a binder to, in order to avoid name capture,
and it is also used to skip renaming a binder if it wouldn't capture any free
variables. Figure~\ref{rapier-style-substitution} shows an implementation of the
technique on the untyped lambda calculus.

\begin{figure}
\begin{verbatim}
data Exp = Var Int | App Exp Exp | Lam Int Exp

substitute :: Set Int -> Subst Exp -> Exp -> Exp
substitute scope s e0 = case e0 of
  Var i -> case lookupSubst i s of Nothing -> e0; Just e -> e
  App e0 e1 -> App (substitute scope s e0) (substitute scope s e1)
  Lam i e
    | member i scope,
      let j = freshVar scope ->
        Lam j $ substitute (insert j scope) (extendSubst s i (Var j)) e
    | otherwise ->
        Lam i $ substitute (insert i scope) (extendSubst s i (Var i)) e

freshVar :: Set Int -> Int
freshVar s = case lookupMax s of Nothing -> 0; Just i -> i + 1
\end{verbatim}
\caption{Rapier style substitution}
\Description{Haskell implementation of substitution for untyped lambda terms using the rapier}
\label{rapier-style-substitution}
\end{figure}

\subsection{The rapier with stronger types}
\label{the-rapier-with-stronger-types}

MacLaurin et al. go over the merits and difficulties of the rapier. In
particular, a few requirements need to be respected when implementing it, or
software faults ensue. Here is a recollection of the requirements in question:
\begin{enumerate}
\item Membership to the scope set needs to be tested for every binder encountered
      during the substitution traversal, and the binders need to be renamed if
      they are in the set.
\item The scope set needs to be constructed correctly before starting a substitution.
      It should contain all of the variables in the result of the substitution,
      and it can also be a superset of those. Since we don't have the result of
      the substitution yet, we turn to specify it in terms of the inputs as well.
      \begin{enumerate}
      \item The scope set needs to include all the variables free in the input
            lambda expression. Otherwise, renaming a variable could accidentally
            capture a free variable. The only exception to this rule are the
            variables that also happen to be in the domain of the substitution
            (binders that capture them don't need to be renamed since the substitution
            will replace occurrences of those free variables).
      \item The scope set needs to include all the variables free in the range
            of the substitution.
      \end{enumerate}
\item Binders need to be added to the scope set whenever they are encountered,
      so further attempts to rename other binders don't capture them.
\item When renaming a binder, the new name must be guaranteed to not belong to
      the scope set.
\item When renaming a binder, the occurrences of the old bound variable need to be
      substituted with the new name.
\item The binders need to be removed from the domain of the substitution when
      they are not in the scope set, otherwise the substitution will happily
      replace occurrences of those bound variables! An alternative we use in
      Figure~\ref{rapier-style-substitution} is to redefine the substitution to
      map the variable of the binder to itself.
\end{enumerate}

In an approach dubbed \textit{The foil}, MacLaurin et al. propose to use the type
checker to ensure most of these
requirements, thus reducing the chance of programmer mistakes. They
propose a library with types \tc{Scope n}, \tc{Name n}, and
\tc{Name\-Binder n l}. A value of type \tc{Scope n} is a set of names, where
the type index \tc{n} identifies the set. A value of type \tc{Name n} is a name that
belongs to the set with type \tc{Scope n}. A value of type \tc{NameBinder n l} is
a name in the set with type \tc{Scope l} which results from adding such single
name to the set with type \tc{Scope n}. These types are meant to be used in
the abstract syntax tree of a client application. For instance

\begin{quotation}
\begin{verbatim}
data Exp n = Var (Name n)
           | App (Exp n) (Exp n)
           | forall l. Lam (NameBinder n l) (Exp l)
\end{verbatim}
\end{quotation}

Then the operations and type checking on the new types will guide the user into
respecting much of the scope requirements when implementing substitution.

\begin{verbatim}
substitute :: Distinct o => Scope o -> Subst Expr i o -> Expr i -> Expr o
\end{verbatim}

This type signature says that no names shadow each other in the scope set \tc{o}.
It also says that the substitution will take a expression with free variables in
a scope set \tc{i} and produce an expression with free variables in a scope set
\tc{o}.

There
are mechanisms to check that a scope set is a subset of another, to assert that no
name shadows another one in a given scope set, to reason that expressions
with free variables in one scope (\tc{Exp n}) can be coerced to expressions with
free variables in a superset (\tc{Exp l}), and to introduce scope sets that extend
others with freshly created names. They also provide an implementation of maps of
variables to expressions, that is the substitutions to apply, with an interface
that uses the new types as well. There is for instance the following function to
produce fresh variables:

\begin{verbatim}
withRefreshed
  :: Distinct o => Scope o -> Name i
  -> (forall (o' :: S). DExt o o' => NameBinder o o' -> r)
  -> r
\end{verbatim}

Using the constraint \tc{DExt}, this type signature says that scope set \tc{o'}
extends the scope set \tc{o} with the given \tc{NameBinder o o'}. This binder
may have the same name as the provided \tc{Name i} if it was not present in
\tc{o}, otherwise it will be a fresh name. As another example, the following
function always produces a fresh name.

\begin{verbatim}
withFresh
  :: Distinct n => Scope n -> (forall l . DExt n l => NameBinder n l -> r )
  -> r
\end{verbatim}

With these measures, the foil is able to address the above requirements except the
last one, which must be handled carefully in the unsafe part of their API. This
is not discussed in their publication, but it can be handled in their \tc{addRename}
function.\footnote{Compare the function \tc{addRename} in the publication with this implementation of it:
{\scriptsize\url{https://hackage.haskell.org/package/free-foil-0.2.0/docs/src/Control.Monad.Foil.Internal.html\#addRename}}}


\subsection{The rapier with refinement types}
\label{the-rapier-with-refinement-types}

We set now to improve upon the rapier with Liquid Haskell. The code presented in
this section is available as
\tc{Subst4.hs}\footnote{The simplest approach with Liquid Haskell: \sourcefile{Subst4.hs}}
in our repository. Liquid Haskell is a
verification tool for Haskell programs. When given a program, the tool will
check statically that the functions in the program respect formal specifications
provided by the programmer. Liquid Haskell doesn't implement all the reasoning
directly. Instead, it will generate logical assertions or constraints from the
abstract syntax tree of the program, that it will then feed to an SMT solver.

Specifications, in turn, are given in a form of dependent types
known as refinement types. A value has a refinement type $\{v:b\ |\ p\ v\}$ when
it has a base type $b$, and it also satisfies predicate $p$. In Liquid Haskell,
$p$ is a function returning a boolean value. Here's an example for the
\tc{freshVar} function.

\begin{verbatim}
import Data.Set
{-@ assume freshVar :: s:Set Int -> {v:Int | not (member v s)} @-}
\end{verbatim}

Liquid Haskell reads refinement type signatures and other annotations from
inside special Haskell comments
\tc{\{-@ \ldots\ @-\}}. We will skip them in our snippets when it is clear
that we are presenting annotations.
The predicates in the refinement types are in a language of expressions
referred to as the logic language. For the sake of this paper, we can
regard it as a subset of Haskell. The predicates are assembled from
functions in the Haskell program and functions that might be available
only in the logic.
A function like \tc{member}, which comes from the module \tc{Data.Set}
in the \tc{containers} package, is linked by Liquid Haskell to the set
theory of the SMT solver.

Refinement type signatures starting with the \tc{assume} keyword declare that the
corresponding Haskell function should honor the signature, but it isn't
checked. When \tc{freshVar} is called in other functions, Liquid Haskell
will assume that the returned variable is fresh whatever the implementation
of \tc{freshVar} does. In contrast, Liquid Haskell is going to check that
the rapier implementation of Figure~\ref{rapier-style-substitution} meets the
following refinement type signature of \tc{substitute}.

\begin{verbatim}
{-@
type ScopedExp S = {e:Exp | isSubsetOf (freeVars e) S}

substitute
  :: scope:Set Int -> s:Subst (ScopedExp scope) -> ScopedExp (domain s)
  -> ScopedExp scope
@-}
substitute :: Set Int -> Subst Exp -> Exp -> Exp
\end{verbatim}

We first define a type alias \tc{ScopeExp S}, that is the type of all
expressions whose free variables are in the set \tc{S}.\footnote{In type aliases,
Liquid Haskell expects parameter names to start with an uppercase letter.}
Then we provide a type signature for the function \tc{substitute} using
refinement types.

Functions like \tc{isSubsetOf} and \tc{difference} come from the \tc{Data.\allowbreak Set}
module. The function \tc{freeVars} is in the same module as \tc{subs\-ti\-tute},
and collects the free variables of an expression. We note that this function
is only used in refinement type signatures, and in particular, it is not evaluated
when calling to \tc{substitute}.

\begin{verbatim}
freeVars :: Exp -> Set Int
freeVars e = case e of
  Var i -> singleton i
  App e1 e2 -> union (freeVars e1) (freeVars e2)
  Lam i e -> difference (freeVars e) (singleton i)
\end{verbatim}

Lastly there is the function \tc{domain} that is defined only in the logic
language.

\begin{verbatim}
{-@ measure domain :: Subst e -> Set Int @-}
\end{verbatim}

This is the way in which uninterpreted functions are declared. The function
\tc{domain} stands for the set of variables in the domain of a substitution.
Liquid Haskel doesn't know anything more about it than its type signature,
but the user can enrich such knowledge within the refinement type signatures
of the substitution operations that manipulate the domain.

\begin{verbatim}
assume lookupSubst :: k:Int -> xs:Subst e
  -> {m:Maybe e | isJust m == member k (domain xs) }

assume extendSubst :: s:Subst a -> i:Int -> a
  -> {v:_ | union (domain s) (singleton i) = domain v }
\end{verbatim}

Now, for instance, whenever Liquid Haskell encounters an application
of the function \tc{lookupSubst}, it will assume that the key is in the domain
of the substitution if the lookup succeeds.

Our refinement type signature of \tc{substitute} follows the type signature of
MacLaurin et al. to the letter. With these annotations, Liquid Haskell can ensure that the
implementation of substitution in Figure~\ref{rapier-style-substitution} meets
all of the requirements in Section~\ref{the-rapier-with-stronger-types}, except
for the first requirement, which we discuss further in the next subsection.

Liquid Haskell ensures the last requirement because the
refinement types of the recursive call demands the free variables of the lambda
body to be in the domain of the substitution. Since these free variables might
contain the binder variable, the substitution is not accepted without extending
it first.

\subsection{Ensuring the scope set is checked}

Checking that the scope set is actually used, and therefore that binders to rename
are not forgotten, admits at least two approaches. In both cases we will prevent
the user from making a recursive call to \tc{substitute} without checking first
if the binder needs renaming.

The first approach prevents the user from inserting a name into a scope if that
name is in the scope already. In such case, a fresh name has to be inserted instead.
And it is not possible to skip updating the scope since the other enforced checks
demand it. This is the new function that we offer to insert elements into a scope
set.

\begin{verbatim}
newtype Scope = UnsafeScope (Set Int)
{-@
withRefreshed :: s:Scope -> i:Int
  -> {p:(Scope, Int) |
       not (member (snd p) s) && fst p == union s (singleton (snd p))}
@-}
withRefreshed :: Scope -> Int -> (Scope, Int)
withRefreshed (UnsafeScope s) i
  | Set.member i s = let j = freshVar s in (UnsafeScope (insert j s), j)
  | otherwise = (UnsafeScope (insert i s), i)
\end{verbatim}

The refinement type signature of the function captures the fact that the returned
name is not in the input set \tc{s}, and that the returned set is an
extension of the input. We also need to wrap our sets of names into a
\tc{newtype} in order to hide the \tc{insert} operation from the programmer,
otherwise she could accidentally omit using \tc{withRefreshed} to create
new scope sets. This solution is available in the file
\tc{Subst5.hs}\footnote{A solution that addresses all requirements: \sourcefile{Subst5.hs}}
in our repository.

The second approach, avoid introducing \tc{withRefreshed} and modifying the
types in the program by providing a more stringent refinement type for
\tc{substitute}.

\begin{verbatim}
substitute
  :: scope:Set Int -> s:Subst (ScopedExp scope) -> ei:ScopedExp (domain s)
  -> {v:Exp | freeVars v == freeVarsSubst (freeVars ei) s}
\end{verbatim}

In this signature we are spelling exactly what the expected free variables in the result are.
We use a function \tc{freeVarsSubst} such that
\tc{freeVarsSubst (freeVars e) s} computes the free variables in the range of the
substitution \tc{s} that is actually used when applying it
to the expression \tc{e}. We provide an example representation for substitutions and
a schematic presentation of \tc{freeVarsSubst}, but in our implementation we
are careful to keep the checks agnostic on the actual representation of
substitutions.

\begin{verbatim}
type Subst e = [(Int, e)]
freeVarsSubst :: Set Int -> Subst Exp -> Set Int
freeVarsSubst used [] = empty
freeVarsSubst used ((i, e) : xs) =
  | member i used = -- only take the first occurrence of i
      union (freeVars e) (freeVarsSubst (difference used (singleton i)) xs)
  | otherwise = freeVarsSubst used xs
\end{verbatim}

Unless we rename all the binders unconditionally, it is no longer
possible to ignore the scope set when going under binders since the calculation
of free variables doesn't add up:
If the name of the binder is in the free variables of the range of the substitution,
it may show up in the free variables of the result, but leaving it unrenamed would
cause the call to the function \tc{freeVars} in the expected return refinement type
to disagree.

Unfortunately, this refinement type signature is more laborious to check, as
\tc{free\-Vars\-Subst} requires roughly one lemma per case of the \tc{subs\-ti\-tute}
function.

\begin{verbatim}
lemma_freeVarsSubst_sing :: i:_ -> s:_
  -> { freeVarsSubst (singleton i) s == freeVarsMaybe (lookupSubst i s) }

lemma_freeVarsSubst_union :: s1:_ -> s2:_ -> s:_
  -> { freeVarsSubst (union s1 s2) s
         == union (freeVarsSubst s1 s) (freeVarsSubst s2 s) }

lemma_freeVarsSubst_extend
  :: scope:_ -> used:_
  -> i:_ -> {e:_ | Data.Set.null (intersection (freeVars e) scope)}
  -> s:Subst (ScopedExp scope)
  -> { freeVarsSubst (difference used (singleton i)) s ==
       difference (freeVarsSubst used (extendSubst s i e)) (freeVars e)
     }
\end{verbatim}

Each lemma requires writing a recursive function for Liquid Haskell to
check it, which is additional effort. Here's the proof for
\tc{lemma\_free\-Vars\-Subst\_union}.

\begin{verbatim}
lemma_freeVarsSubst_union :: Set Int -> Set Int -> Subst Exp -> ()
lemma_freeVarsSubst_union _ _ [] = ()
lemma_freeVarsSubst_union s1 s2 ((i, _) : xs) =
  lemma_freeVarsSubst_union
    (difference s1 (singleton i)) (difference s2 (singleton i)) xs
\end{verbatim}

The recursive function follows the structure of an inductive proof,
with much of the folding, unfolding, and set properties applied
automatically. And this is similar for the proofs of the other lemmas.
Then the lemmas need to be applied in the cases of \tc{substitute}.

\begin{verbatim}
substitute scope s e0 = case e0 of
  Var i -> case lookupSubst i s of
    Nothing -> e0
    Just e -> e ? lemma_freeVarsSubst_sing i s
  App e0 e1 ->
    App (substitute scope s e0) (substitute scope s e1)
      ? lemma_freeVarsSubst_union (freeVars e0) (freeVars e1) s
  Lam i e
    ...
\end{verbatim}

The operator \tc{?} is an alias for function \tc{const = \textbackslash x \_ -> x} and
brings the lemma into consideration of Liquid Haskell when checking the
first argument without evaluating the recursive function that stands for
the lemma proof. This solution is available in the file
\tc{Subst3.hs}\footnote{A solution that addresses all requirements without changing types in the program: \sourcefile{Subst3.hs}}
in our repository.


\subsection{Comparison}

Liquid Haskell can ensure most of the requirements with little assistance
because it is delegating much of the work to an underlying SMT solver.
SMT solvers are tools that decide whether (usually first order) logic formulas are
satisfiable and provide dedicated mechanisms to reason about various theories
(sets, strings, arrays, integers, reals, etc).

In the case of capture-avoiding substitution, multiple queries that
Liquid Haskell gives to the SMT solver involve reasoning on sets, thus
making effective use of its capabilities. Moreover, the expression of
relationships between arguments and result is fairly natural with
refinement types. When there are lemmas to prove, despite of being
additional effort to write, they still have proofs that don't require
a lot of creativity.

On the other hand, an approach like the foil does need the author to
think carefully about how to encode the various static checks with the
type checker, a non trivial supporting library needs to be written,
and the effort might need further iterations when accounting for
additional properties.
We will have more to say on the experience of implementing API checks
after our next case study.

\section{Unification}
\label{unification}

In this section we look now at another example where we can put the set theory
of SMT solvers to work for us. This is conditional unification of a form of
hereditary Harrop formulas. Unlike in the previous section, the reasoning
presented in this section is not fully implemented in Liquid Haskell, and this
is why our achievement is partial. In Section~\ref{limitations} we discuss the
unimplemented parts.

As before, variables are represented as integers, and we also have a form of
skolem function application $f(t_0,\ldots,t_n)$ represented as a pair
$(f, [x_0:=t_0,\ldots,x_n:=t_n])$, where $x_0 \ldots x_n$ are the only free
variables allowed in the solutions of $f$.

\begin{verbatim}
type Var = Int
type SkolemApp = (Var, Subst Term)
\end{verbatim}

The purpose of the skolem $f(t_0,\ldots,t_n)$ is to replace existential variables
in a formula like $\forall x. \exists z. z = x$ to get $\forall x. f_z(x) = x$, which
in our representation will be $\forall x. (f_z, [x:=x]) = x$.
The purpose of unification would be to find a value of $f_z$ that only has the variable
$x$ free, and that makes the formula true.

\begin{verbatim}
data Term
  = V Var | SA SkolemApp | U | L Term | P Term Term deriving

data Formula
  = Eq Term Term               -- equality
  | Conj Formula Formula       -- conjunctions
  | Then (Term, Term) Formula  -- a = b => f
  | Exists Var Formula         -- existential quantification
  | Forall Var Formula         -- universal quantification
\end{verbatim}

Our term language allows for variables, skolem applications, and some artificial
data constructors (i.e. injective functions). The language of formulas has
equality, conjunction, existential and universal quantification, and it also
has a form of implication that only allows for equalities in the antecedent.
The conception is driven by the simplest language that still would allow to
express something of practical interest like constraints of generalized
algebraic data types.

Our unification algorithm is then expressed in Figure~\ref{conditional-unification}.
When unification fails, we return an incomplete list of solutions, that is one that
doesn't provide solutions for all the skolems in a formula.
There are a few preparation passes on unification formulas that we have elided since
they aren't essential to the discussion in this section.
Existential variables would be replaced with skolem applications, equalities of
data constructors like $P a b = P c d \Rightarrow f$ are split to
$a = c \land b = d \Rightarrow f$, formulas are normalized to prenex form, variables
are renamed to avoid name captures, etc. We have functions \tc{substitute} and
\tc{substituteSkolems} to apply substitutions in terms and substitutions of skolems
in formulas. And we also have a function \tc{skolemSet} to collect the skolems of a
term.

\begin{figure}
\begin{verbatim}
unify :: Formula -> [(Var, Term)]
unify (Forall v f) = unify f
unify (Exists v f) = unify f
unify (Conj f1 f2) = unify f1 ++ unify f2
unify (Then (t0, t1) f2) =
  let unifsT1 = unifyEq t0 t1
   in unifsT1 ++ unify (substituteSkolems unifsT1 f2)
unify (Eq t0 t1) = unifyEq t0 t1

unifyEq :: Term -> Term -> [(Var, Term)]
unifyEq t0 t1@(SA (i, s))
  | Just s' <- inverseSubst $ narrowForInvertibility (freeVars t0) s
  , let t' = substitute s' t0
  , not (Set.member i (skolemSet t'))
  , Set.isSubsetOf (freeVars t') (domain s)
  = [(i, t')]
unifyEq t0@(SA _) t1 = unifyEq t1 t0
unifyEq _ _ = []

-- | @narrowForInvertibility vs s@ removes pairs from @s@ if the
-- range is not a variable, or if the range is not a member of @vs@.
narrowForInvertibility :: Set Var -> Subst Term -> Subst Term
narrowForInvertibility vs (Subst xs) =
  Subst [(i, V j) | (i, V j) <- xs, Set.member j vs]

inverseSubst :: Subst Term -> Maybe (Subst Term)
inverseSubst (Subst xs) = fmap Subst (go xs)
  where
    go [] = Just []
    go ((i, V j) : xs) = fmap ((j, V i) :) (go xs)
    go _ = Nothing
\end{verbatim}
\caption{Conditional unification}
\Description{Haskell implementation of condition unification}
\label{conditional-unification}
\end{figure}

The function \tc{unifyEq} defines what a good solution should be.
One of the conditions is that whatever term \tc{t'} is proposed
as solution for a skolem \tc{i}, it needs to have as free variables only those in the
domain of the substitution defining the skolem application
(\textit{scope check}). Another
condition is that the skolem \tc{i} should not occur in the solution
\tc{t'} (\textit{occurs check}). And since we are inverting a substitution to find
\tc{t'}, we might not find solutions if we cannot invert the
substitution. This implementation only inverts substitutions where
variables are mapped to variables. That is, we solve $(f, [z:=x]) = L(L(x))$
to get the solution $(f, L(L(z)))$ but we do not try solving $(f, [z:=L(x)]) = L(L(x)))$.

\subsection{Checking \tc{unifyEq}}

We start introducing static checks by providing a refinement type signature to
the function \tc{unifyEq}, which encodes the scope check, the occurs check,
and the relationship of skolems present in the result and in the arguments.

\begin{verbatim}
unifyEq
  :: t0:Term
  -> {t1:Term | unionCommutes (scopesTerm t0) (scopesTerm t1)}
  -> [(v :: Var
      , { t:Term |
             isSubsetOfJust (freeVars t)
               (Map.lookup v (Map.union (scopesTerm t0) (scopesTerm t1)))
          && not (Set.member v (skolemSet t))
          && Map.isSubsetOf (scopesTerm t)
               (Map.union (scopesTerm t0) (scopesTerm t1))
        }
      )] / [terminationUnifyEq t0 t1]
\end{verbatim}

The function \tc{scopesTerm} is only used in refinement types and it produces
a projection of the skolem applications in a given term. Instead of returning
full skolem applications, it only provides the skolem name and the domain of
the substitution.

\begin{verbatim}
scopesTerm :: Term -> Map Var (Set Int)
scopesTerm (V i) = Map.empty
scopesTerm (SA (i, s)) = Map.singleton i (domain s)
scopesTerm U = Map.empty
scopesTerm (L t) = scopesTerm t
scopesTerm (P t0 t1) = Map.union (scopesTerm t0) (scopesTerm t1)
\end{verbatim}

We define the predicate \tc{isSubsetOfJust} to say that the lookup succeeds
and that it yields a superset of the first argument.

\begin{verbatim}
isSubsetOfJust :: Ord a => Set a -> Maybe (Set a) -> Bool
isSubsetOfJust xs (Just ys) = Set.isSubsetOf xs ys
isSubsetOfJust xs Nothing = False
\end{verbatim}

We assume the function \tc{Map.union} to be commutative despite of it being
defined as left-biased in the \tc{containers} package. This is because we
rely on the preceding passes of unification to ensure that everywhere a
skolem occurs, the domain of the substitution is always the same.

\begin{verbatim}
unionCommutes :: Set a -> Set a -> Bool
unionCommutes s0 s1 = Map.union s0 s1 == Map.union s1 s0
\end{verbatim}

The function \tc{terminationUnifyEq} is a metric that we provide so Liquid
Haskell can check that \tc{unifyEq} terminates. When the recursion is
structural, termination can be proved without extra considerations, but in
this case we are doing a recursive call that swaps the order of the arguments.
The metric that we provide must be greater or equal to 0 and must decrease on
each recursive call.

\begin{verbatim}
{-@ terminationUnifyEq :: Term -> Term -> {v:Int | v >= 0} @-}
terminationUnifyEq :: Term -> Term -> Int
terminationUnifyEq (SA _) _ = 1
terminationUnifyEq _ (SA _) = 0
terminationUnifyEq _ _ = 0
\end{verbatim}

When checking \tc{unifyEq}, the two first conjuncts of the return type can
be easily established since they match exactly the guards in the first equation.
The last conjunct demands more calculation.

If we substitute \tc{t} by \tc{substitute s'} in the last conjunct, we get that we
need to prove

\begin{verbatim}
Map.isSubsetOf (scopesTerm (substitute s' t0)
               (Map.union (scopesTerm t0) (scopesTerm t1))
\end{verbatim}

Liquid Haskell does compute this on its own. Then we can use the fact that substitution
preserves the skolems returned by \tc{scopesTerm} to arrive at

\begin{verbatim}
Map.isSubsetOf (scopesTerm t0) (Map.union (scopesTerm t0) (scopesTerm t1))
\end{verbatim}

And this statement the SMT solver can prove on its own using the theory of arrays,
which can be used to implement maps. The only step that the user needs to spell out
is the property relating \tc{substitute} and \tc{scopesTerm}.

\begin{verbatim}
lemmaSubstituteScopesTerm
  :: s:Subst {ti:Term | isVar ti} -> t:Term
  -> { scopesTerm t = scopesTerm (substitute s t) }
\end{verbatim}

The range of the substitution \tc{s} is required to only contain variables, but
this is exactly what \tc{inverseSubst} produces!

\begin{verbatim}
isVar :: Term -> Bool
isVar (V _) = True
isVar _ = False

{-@ inverseSubst :: Subst Term -> {v:Subst {t:Term | isVar t} @-}
\end{verbatim}

\subsection{Checking \tc{unify}}

In the same way as in the previous section, we start checking the function \tc{unify}
by providing a refinement type signature. This is a rephrasing of the refinement
types of \tc{unifyEq} when the input is formula instead of a pair of terms.

\begin{verbatim}
unify
  :: {f:Formula | consistentSkolemScopes f}
  -> [(v :: Var
      , { t:Term |
             isSubsetOfJust (freeVars t) (Map.lookup v (scopes f))
          && not (Set.member v (skolemSet t))
          && Map.isSubsetOf (scopesTerm t) (scopes f)
        }
      )] / [formulaSize f]
\end{verbatim}

The recursion of unify is not structural since in the implication case we
are chaining the recursive calls. Therefore we provide a termination
metric \tc{formulaSize} that counts the amount of connectives in a formula.
We also define a function \tc{scopes} analogous to \tc{scopesTerm} to obtain the skolems
of a formula.

\begin{verbatim}
scopes :: Formula -> Map Var (Set Int)
scopes (Forall _ f) = scopes f
scopes (Exists _ f) = scopes f
scopes (Conj f1 f2) = Map.union (scopes f1) (scopes f2)
scopes (Then (t0, t1) f2) =
  Map.union (scopesTerm t0) (Map.union (scopesTerm t1) (scopes f2))
scopes (Eq t0 t1) = Map.union (scopesTerm t0) (scopesTerm t1)
\end{verbatim}

We also define the predicate \tc{consistentSkolemScopes}, which ensures that
all occurrences of a skolem have the same domain.

\begin{verbatim}
consistentSkolemScopes :: Formula -> Bool
consistentSkolemScopes (Forall _ f) = consistentSkolemScopes f
consistentSkolemScopes (Exists _ f) = consistentSkolemScopes f
consistentSkolemScopes (Conj f1 f2) =
      consistentSkolemScopes f1 && consistentSkolemScopes f2
  &&  unionCommutes (scopes f1) (scopes f2)
consistentSkolemScopes (Then (t0, t1) f2) =
     consistentSkolemScopes f2
  && unionCommutes (scopesTerem t0) (scopesTerm t1)
  && unionCommutes (Map.union (scopesTerem t0) (scopesTerm t1)) (scopes f2)
consistentSkolemScopes (Eq t0 t1) =
  unionCommutes (scopesTerm t0) (scopesTerm t1)
\end{verbatim}

Liquid Haskell can check automatically the refinement type signature of
\tc{unify}. In the case of quantifiers, unfolding definitions of
\tc{scopes} plus the refinement type of the recursive calls suffices.
In the case of conjunction, the theory of arrays of the SMT solver
kicks in to establish the last conjunct of the refinement type:

\begin{verbatim}
(Map.isSubsetOf (scopesTerm t) (scopes f1) =>
  Map.isSubsetOf (scopesTerm t) (Map.union (scopes f1) (scopes f2)))
&&
(Map.isSubsetOf (scopesTerm t) (scopes f2) =>
  Map.isSubsetOf (scopesTerm t) (Map.union (scopes f1) (scopes f2)))
\end{verbatim}

For the first conjunct of the refinement type we also need to prove

\begin{verbatim}
unionCommutes (scopes f1) (scopes f2)
=>
(isSubsetOfJust (freeVars t) (Map.lookup v (scopes f1)) =>
  isSubsetOfJust (freeVars t)
                 (Map.lookup v (Map.union (scopes f1) (scopes f2))))
&&
(isSubsetOfJust (freeVars t) (Map.lookup v (scopes f2)) =>
  isSubsetOfJust (freeVars t)
                 (Map.lookup v (Map.union (scopes f1) (scopes f2))))
\end{verbatim}

The antecedent of the above goal is established by \tc{consistent\-Skolem\-Scopes}
in the refinement type of the input. The other equations in \tc{unify}
are checked using similar reasoning, all of it automatic.


TODO
\begin{itemize}
\item write a version of Unif2.hs that has terminationUnifyEq and lemmaSubstituteScopesTerm
\item show the proof of lemmaSubstituteScopesTerm
\item show the proof of lemmaSubstituteScopesTerm
\item (defer discussing the workaround lemmas to the section on limitations).
\end{itemize}


\section{Limitations of API checks with SMT solvers}
\label{limitations}

\section{Conclusions}
\label{conclusions}


\bibliographystyle{plain}
\bibliography{references}
\end{document}
